## Проектирование масштабируемой и устойчивой системы для обработки пользовательских заявок

### 1. Выбор архитектурного стиля

#### Функциональные требования:

- Пользователь может создать, просмотреть и обновить заявку.
- Администратор может просматривать и изменять статус заявок.
- Система отправляет уведомления при изменении статуса заявки.
- Поддержка аутентификации и авторизации.

#### Нефункциональные требования:

- Высокая доступность (99.9%+).
- Масштабируемость по числу пользователей.
- Обработка пиковых нагрузок (например, в часы пик).
- Согласованность данных между модулями.
- Устойчивость к сбоям отдельных компонентов.
- Возможность независимого развертывания и обновления компонентов.

#### Выбор архитектурного стиля: **Микросервисная архитектура**

**Обоснование:**

- Возможность независимого масштабирования различных компонентов.
- Устойчивость: сбой одного сервиса не влияет на всю систему.
- Гибкость в выборе технологий и возможность команды разрабатывать компоненты независимо.
- Поддержка DevOps/CI-CD процессов.

---

### 2. Сбор требований

#### Ключевые функциональные требования:

- CRUD-операции над заявками.
- Авторизация/аутентификация.
- Уведомление пользователей.
- Панель администратора.

#### Ключевые нефункциональные требования:

- Высокая доступность: >99.9%.
- Масштабируемость (горизонтальная).
- Устойчивость к сбоям.
- Время отклика API: <500 мс.
- Хранение истории изменений заявок.

#### SLA / SLO / SLI:

| Метрика                                       | Значение                    |
| --------------------------------------------- | --------------------------- |
| **SLA** (Доступность сервиса)                 | 99.9%                       |
| **SLO** (Среднее время ответа на запрос)      | < 500 мс                    |
| **SLO** (Максимальное время обработки заявки) | < 2 сек                     |
| **SLI** (Error rate)                          | < 0.1% 5xx на 1000 запросов |

---

### 3. Применение шаблонов проектирования

#### 1. **CQRS (Command Query Responsibility Segregation)**

**Где:** В сервисе заявок.

**Зачем:**

- Разделяет операции изменения и чтения.
- Позволяет масштабировать чтение отдельно.
- Использовать разные модели данных и репозиториев для записи и чтения.


### 4. Кэширование и масштабирование

#### Стратегии кэширования:

- Использование **Redis** для кэширования часто читаемых данных.
- Кэширование аутентификационных токенов (JWT).
- HTTP-level кэширование ответов на GET-запросы.

#### Масштабирование:

- **Горизонтальное масштабирование** API Gateway, сервисов и баз данных.
- Использование очередей (Kafka) для асинхронной обработки заявок и уведомлений.
- CDN для доставки статики (если будет веб-интерфейс).


### 5. Диаграмма архитектуры (System Context Diagram)

В файле Схема Гагарин А.Ю.drawio


### 6. Вывод

- Микросервисная архитектура обеспечивает масштабируемость и устойчивость.
- CQRS помогает разделить зоны ответственности и масштабировать чтение.
- Используемые метрики SLA/SLO/SLI позволяют контролировать качество сервиса.



